# Testing

Based on upstreams documentation https://github.com/thtanaka/kubernetes/blob/master/docs/devel/testing.md we use three levels of testing: unit, integration and e2e.

Before starting, run `make tools` to install the required dependencies.

Running `make test` executes all the test suites.

We use ginkgo for testing. Every package needs a `suite_test.go` for setup. It can be generated by running `ginkgo bootstrap` in the sub folder. Rename the generated file afterwards, to stay consistent.
There is also `ginkgo generate` to create skeleton test files.

## Unit

While unit testing we:

* test classes in isolation
* pass all dependencies to the constructor, so we can inject fakes for testing
* use `counterfeiter` to generate and update fakes
* don't test private methods, tests are in a separate `_test` package
* try not to nest ginkgo contexts too deep and keep tests DRY by extracting useful helpers
* assert incoming messages produce the expected state
* assert outgoing commands happened, like a file gets written
* assert all handled error cases are triggered
* can ignore outgoing queries, which only change internal state


### Setup Ruby

Ruby gem for template rendering

    gem install bosh-template

## Integration

Integration tests formulate expectations on the interactions of several components.
They require access to a Kubernetes, preferably `minikube`.

Integration tests start our operator directly, bypassing the command line.

The `environment` package provides helpers to start the operator, get the kubeconfig and use the clients to create objects.
In `testing` the `catalog` defines test objects.

Integration tests use a special logger, which does not log to stdout and whose messages can be accessed as a an array by calling `env.AllLogMessages()`.

### Setup Webhook Host

Extended StatefulSet requires a k8s webhook to mutate the volumes of a pod.
Kubernetes will call back to the operator for certain requests and use the
modified pod manifest, which is returned.  The cf-operator binary will open a
listening port bound to `OPERATOR_WEBHOOK_HOST` on port
`OPERATOR_WEBHOOK_PORT`.

The tests use a `mutatingwebhookconfiguration` to configure Kubernetes to
connect to this address.  It needs to be reachable from the cluster.

In case of minikube on Linux, the following one liner exports the public IP of
the interface used for the default route:

    export OPERATOR_WEBHOOK_HOST=$(ip -4 a s dev `ip r l 0/0 | cut -f5 -d' '` | grep -oP 'inet \K\S+(?=/)')

### Upload Operator Image

Template rendering for BOSH jobs is done at deployment time by the operator
binary. Therefore the operator docker image needs to be made available to
Kubernetes cluster.

For running integration tests locally against minikube, we switch to minikubes
docker daemon, build the binary, copy it to a docker image and finally start
the tests:

    eval `minikube docker-env`
    bin/build; bin/build-nobuild-image
    bin/test-integration

## End-to-End

The e2e tests are meant to test acceptance scenarios. They are written from an end user perspective. They also require a running Kubernetes, but build our operator CLI themselves.

Currently we only have e2e tests for the command line options.
